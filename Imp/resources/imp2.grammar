start = @(namespace_class, newlines, 1, 0)

namespace_class = namespace | class
snippet_entry = @(snippet_function, semicolon_or_newline, 1, 0)
comma_or_newline = comma | newlines

value = string | bool | int | float

arguments = group_start @(expression, comma_or_newline, 0, 0) group_end

reference_token = id @(arguments, 0, 1)

index = array_start expression array_end

id_with_optional_index = id @(index, 0, 1)

reference = @(id_with_optional_index, path_separator, 1, 0) @(arguments, 0, 1)

declare_symbol = id @(type_info, 0, 1)

type_info = colon type

type = @(id, path_separator, 1, 0) @(optional_list_suffix, 0, 1)

optional_list_suffix = array_start array_end

statement =
	declare_variable
	| if
	| while
	| return
	| for
	| assignment
	| expression


expression_part =
	  instantiate
	| value
	| lambda
	| reference	
	| closed_expression


closed_expression = group_start expression group_end

expression = @(expression_part, operation_separator, 1, 0)

namespace = "namespace" id "{" @(class, newlines, 0, 0) "}"

function_definition = @(function_attribute, 0, 1) id group_start @(declare_symbol, comma, 0, 0) group_end @(type_info, 0, 1) @(optional_long_block, 0, 1)

snippet_function = @(function_attribute, 0, 1) id group_start @(declare_symbol, comma, 0, 0) group_end @(type_info, 0, 1) long_block_any

function_attribute =  "private"

class_statements = function_definition | property_declaration

property_declaration = id type_info

class = @(class_attribute, 0, 0) "class" id @(optional_parent_classes, 0, 1) "{" @(class_statements, newlines, 0, 0) "}"

class_attribute = "abstract"

optional_parent_classes = colon @(id, comma_or_newline, 1, 0) trim

block = long_block | short_block

optional_long_block = long_block

short_block = one_or_no_newline statement

long_block = block_start @(statement, semicolon_or_newline, 0, 0) block_end

long_block_any = block_start any_statement block_end

any_statement = class | statements

statements = @(statement, semicolon_or_newline, 0, 0)

if = "if" group_start expression group_end block

while = "while" group_start expression group_end block

optional_expression = spaces expression

return = "return" @(optional_expression, 0, 1)

optional_assignment = equals expression

declare_variable = "var" id @(type_info, 0, 1) @(optional_assignment, 0, 1)

assignment = reference set_operator expression

for = "for" group_start "var" id "in" reference group_end long_block

instantiate = "new" type arguments

lambda = group_start @(declare_symbol, comma, 0, 0) group_end arrow block